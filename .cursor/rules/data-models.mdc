---
globs: lib/models/*
---

# Data Model Guidelines

## Model Structure Rules

All models should follow these patterns:

### 1. Simple Class Structure (NO freezed)
```dart
class ModelName {
  final Type property;
  
  ModelName({required this.property});
  
  // copyWith for immutability
  ModelName copyWith({Type? property}) {
    return ModelName(
      property: property ?? this.property,
    );
  }
  
  // Serialization
  Map<String, dynamic> toJson() {
    return {'property': property};
  }
  
  factory ModelName.fromJson(Map<String, dynamic> json) {
    return ModelName(property: json['property']);
  }
}
```

## Required Models

### AlchemyStep (models/alchemy_step.dart)
Represents a single step in the 12-step sequence.

```dart
class AlchemyStep {
  final int stepNumber;        // 1-12
  final String action;         // 'dissolve', 'combine', 'calcify', 'sublimate'
  final String material;       // 'red_lion', 'white_eagle', 'sulfur', 'mercury', etc.
  final bool isCompleted;      // For tracking progress in Laboratory
  final bool isCorrect;        // For validation results
  
  AlchemyStep({
    required this.stepNumber,
    required this.action,
    required this.material,
    this.isCompleted = false,
    this.isCorrect = true,
  });
  
  // Add copyWith, toJson, fromJson
}
```

### Recipe (models/recipe.dart)
Represents a complete 12-step recipe (user's attempt).

```dart
class Recipe {
  final List<AlchemyStep> steps;     // Always 12 steps
  final bool isLocked;               // True once locked for Laboratory
  final DateTime creationDate;       // When recipe was created
  final int attemptNumber;           // Attempt #1, #2, etc.
  
  Recipe({
    required this.steps,
    this.isLocked = false,
    required this.creationDate,
    required this.attemptNumber,
  });
  
  // Helper methods
  bool isComplete() {
    return steps.length == 12 && 
           steps.every((step) => step.action.isNotEmpty && step.material.isNotEmpty);
  }
  
  // Add copyWith, toJson, fromJson
}
```

### GameState (models/game_state.dart)
Represents the overall game state (for persistence).

```dart
class GameState {
  final int currentAttempt;              // Current attempt number
  final List<Recipe> craftingLog;        // History of all attempts
  final List<Revelation> revelations;    // All revelations (locked/unlocked)
  final bool soundEnabled;               // Settings
  final bool musicEnabled;               // Settings
  final String textSpeed;                // 'slow', 'normal', 'fast'
  final Recipe? currentRecipe;           // Recipe in progress (if any)
  
  GameState({
    required this.currentAttempt,
    required this.craftingLog,
    required this.revelations,
    this.soundEnabled = true,
    this.musicEnabled = true,
    this.textSpeed = 'normal',
    this.currentRecipe,
  });
  
  // Factory for initial state
  factory GameState.initial() {
    return GameState(
      currentAttempt: 1,
      craftingLog: [],
      revelations: _createInitialRevelations(),
      soundEnabled: true,
      musicEnabled: true,
      textSpeed: 'normal',
    );
  }
  
  static List<Revelation> _createInitialRevelations() {
    // Return list of all possible revelations (mostly locked)
    return [
      Revelation(
        title: 'The Nature of the Lion',
        description: 'The Green Lion must be the first to be tamed...',
        isUnlocked: false,
        unlockRequirement: 1, // Unlocks after first attempt
      ),
      // Add more revelations
    ];
  }
  
  // Add copyWith, toJson, fromJson
}
```

### Revelation (models/revelation.dart)
Represents unlockable knowledge/hints.

```dart
class Revelation {
  final String title;
  final String description;        // Full revelation text
  final bool isUnlocked;
  final int unlockRequirement;     // Min attempts needed to unlock
  
  Revelation({
    required this.title,
    required this.description,
    this.isUnlocked = false,
    required this.unlockRequirement,
  });
  
  // Add copyWith, toJson, fromJson
}
```

### AttemptRecord (models/attempt_record.dart)
Detailed record of a single attempt (used in Crafting Log).

```dart
class AttemptRecord {
  final int attemptNumber;
  final DateTime timestamp;
  final Recipe attemptedRecipe;
  final bool wasSuccessful;
  final int? failedAtStep;         // null if successful, 1-12 if failed
  final String? failureReason;     // e.g., "Executed [Calcify] instead of [Sublimate]"
  final String? failureCause;      // e.g., "Used [Red Lion] instead of [White Eagle]"
  
  AttemptRecord({
    required this.attemptNumber,
    required this.timestamp,
    required this.attemptedRecipe,
    required this.wasSuccessful,
    this.failedAtStep,
    this.failureReason,
    this.failureCause,
  });
  
  // Add copyWith, toJson, fromJson
}
```

## Serialization Guidelines

### JSON Encoding
- Use simple types: String, int, bool, List, Map
- Convert DateTime to ISO8601 string: `dateTime.toIso8601String()`
- Convert enums to strings: `action.toString().split('.').last`

### JSON Decoding
- Parse DateTime from string: `DateTime.parse(json['timestamp'])`
- Handle null values with null-aware operators
- Provide default values for optional fields

### Example:
```dart
Map<String, dynamic> toJson() {
  return {
    'stepNumber': stepNumber,
    'action': action,
    'material': material,
    'isCompleted': isCompleted,
    'isCorrect': isCorrect,
  };
}

factory AlchemyStep.fromJson(Map<String, dynamic> json) {
  return AlchemyStep(
    stepNumber: json['stepNumber'] as int,
    action: json['action'] as String,
    material: json['material'] as String,
    isCompleted: json['isCompleted'] as bool? ?? false,
    isCorrect: json['isCorrect'] as bool? ?? true,
  );
}
```

## Model Best Practices

1. **Immutability**: All fields should be `final`
2. **Named Constructors**: Use named constructors for special cases (e.g., `GameState.initial()`)
3. **Validation**: Add validation methods when needed (e.g., `isComplete()`)
4. **Equality**: Override `==` and `hashCode` if models will be compared
5. **Documentation**: Add comments explaining complex fields
6. **Null Safety**: Use nullable types (`?`) only when truly optional

## Testing Models
Each model should be easy to test:
- Can create instances with known values
- Can serialize to JSON and deserialize back
- `copyWith` creates new instances with updated values
- Factory constructors work correctly
