---
description: Testing strategies and guidelines for Cognifex
---

# Testing Guidelines

## Testing Philosophy

For this project, focus on:
1. **Core game logic testing** - Recipe validation is critical
2. **Model serialization** - Ensure data persists correctly
3. **Manual UI testing** - No need for extensive widget tests initially
4. **Edge case handling** - Test failure scenarios

## Test Structure

```
test/
├── models/
│   ├── alchemy_step_test.dart
│   ├── recipe_test.dart
│   ├── game_state_test.dart
│   └── revelation_test.dart
├── utils/
│   ├── game_logic_test.dart
│   └── storage_service_test.dart
└── widget_tests/
    └── (optional widget tests)
```

## Unit Tests for Models

### Test Model Serialization
```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('AlchemyStep', () {
    test('should serialize to JSON and deserialize back', () {
      final step = AlchemyStep(
        stepNumber: 1,
        action: 'dissolve',
        material: 'red_lion',
      );
      
      final json = step.toJson();
      final deserialized = AlchemyStep.fromJson(json);
      
      expect(deserialized.stepNumber, step.stepNumber);
      expect(deserialized.action, step.action);
      expect(deserialized.material, step.material);
    });
    
    test('copyWith should create new instance with updated values', () {
      final step = AlchemyStep(
        stepNumber: 1,
        action: 'dissolve',
        material: 'red_lion',
      );
      
      final updated = step.copyWith(isCompleted: true);
      
      expect(updated.isCompleted, true);
      expect(updated.stepNumber, step.stepNumber);
    });
  });
}
```

## Unit Tests for Game Logic

### Test Recipe Validation (CRITICAL)
```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('GameLogic', () {
    test('should validate correct recipe step', () {
      final gameLogic = GameLogic();
      final correctStep = gameLogic.getCorrectStep(0); // Step 1
      
      final result = gameLogic.validateStep(correctStep, 0);
      
      expect(result, true);
    });
    
    test('should reject incorrect action', () {
      final gameLogic = GameLogic();
      final correctStep = gameLogic.getCorrectStep(0);
      final wrongStep = correctStep.copyWith(action: 'wrong_action');
      
      final result = gameLogic.validateStep(wrongStep, 0);
      
      expect(result, false);
    });
    
    test('should reject incorrect material', () {
      final gameLogic = GameLogic();
      final correctStep = gameLogic.getCorrectStep(0);
      final wrongStep = correctStep.copyWith(material: 'wrong_material');
      
      final result = gameLogic.validateStep(wrongStep, 0);
      
      expect(result, false);
    });
    
    test('should validate all 12 steps correctly', () {
      final gameLogic = GameLogic();
      
      for (int i = 0; i < 12; i++) {
        final step = gameLogic.getCorrectStep(i);
        expect(gameLogic.validateStep(step, i), true);
      }
    });
  });
}
```

## Testing Storage Service

### Mock SharedPreferences
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() {
  group('StorageService', () {
    setUp(() {
      // Set up mock values before each test
      SharedPreferences.setMockInitialValues({});
    });
    
    test('should save and load game state', () async {
      final storage = StorageService();
      final gameState = GameState.initial();
      
      await storage.saveGameState(gameState);
      final loaded = await storage.loadGameState();
      
      expect(loaded, isNotNull);
      expect(loaded!.currentAttempt, gameState.currentAttempt);
    });
    
    test('should return null when no data exists', () async {
      final storage = StorageService();
      
      final loaded = await storage.loadGameState();
      
      expect(loaded, isNull);
    });
    
    test('should clear all data', () async {
      final storage = StorageService();
      await storage.saveGameState(GameState.initial());
      
      await storage.clearAll();
      final loaded = await storage.loadGameState();
      
      expect(loaded, isNull);
    });
  });
}
```

## Integration Testing Scenarios

### Critical User Flows to Test Manually:
1. **First Launch**
   - App loads with empty state
   - Can navigate to all screens
   - Settings work correctly

2. **Complete Study Flow**
   - Fill all 12 recipe steps
   - Lock recipe (confirmation modal appears)
   - Confirm and enter Laboratory

3. **Laboratory Success Flow**
   - Execute all 12 steps correctly
   - See success messages after each step
   - Reach victory screen
   - Victory is recorded in Crafting Log

4. **Laboratory Failure Flow**
   - Execute steps correctly up to step X
   - Execute wrong action/material
   - See failure message immediately
   - Navigate to failure screen
   - Attempt is recorded with error details

5. **Persistence Test**
   - Create recipe in Study
   - Close app (kill process)
   - Reopen app
   - Verify recipe is still there

6. **Settings Test**
   - Toggle sound/music
   - Change text speed
   - Close and reopen app
   - Verify settings persist

7. **Revelation Unlock Test**
   - Complete X attempts
   - Check revelations screen
   - Verify correct revelations unlocked

## Edge Cases to Test

1. **Empty/Partial Recipe**
   - Try to lock recipe with missing steps
   - Should show error or disable lock button

2. **Rapid Button Presses**
   - Tap Execute button multiple times quickly
   - Should not execute step twice

3. **Back Navigation**
   - Try to go back from Laboratory to Study
   - Should prevent or show warning

4. **Large Attempt History**
   - Create 50+ attempts
   - Verify app still performs well
   - Check storage limits

5. **App Lifecycle**
   - Background app during Laboratory execution
   - Return to app
   - Verify state preserved

## Performance Testing

### Areas to Monitor:
1. **JSON Serialization** - Large GameState objects
2. **Scroll Performance** - Long Crafting Log lists
3. **Animation Performance** - Shake/pulse effects
4. **Storage Operations** - Save/load times

### Tools:
- Flutter DevTools Performance tab
- `flutter run --profile` for realistic performance
- Monitor frame rendering times

## Debugging Tips

### Common Issues:
1. **Serialization Errors**
   - Check JSON structure matches model
   - Ensure all fields have defaults

2. **State Not Persisting**
   - Verify save() is being called
   - Check SharedPreferences keys are correct

3. **Validation Always Failing**
   - Print out expected vs actual values
   - Check enum string conversions

### Debug Helpers:
```dart
// Add to game_logic.dart for testing
void printCorrectRecipe() {
  for (var step in correctRecipe) {
    print('Step ${step.stepNumber}: ${step.action} + ${step.material}');
  }
}
```

## Manual Testing Checklist

Before release, test:
- [ ] All 13 screens render correctly
- [ ] Navigation works in all directions
- [ ] Recipe can be created and locked
- [ ] All 12 steps execute correctly with right recipe
- [ ] Failure occurs immediately with wrong step
- [ ] Crafting log displays all attempts
- [ ] Revelations unlock at correct times
- [ ] Settings persist across app restarts
- [ ] Reset progress clears all data
- [ ] Victory and failure screens display correctly
- [ ] App works on iOS and Android
- [ ] App works on different screen sizes
- [ ] No crashes or errors in console

## Test Coverage Goals

- **Models**: 90%+ coverage
- **Game Logic**: 100% coverage (critical path)
- **Storage Service**: 80%+ coverage
- **Widgets**: 50%+ coverage (optional)

Focus on testing what breaks the game, not coverage percentage.
