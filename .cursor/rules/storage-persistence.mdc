---
globs: lib/utils/storage_service.dart
---

# Storage & Persistence Guidelines

## Storage Service (utils/storage_service.dart)

Use `shared_preferences` package for all data persistence.

### Service Structure

```dart
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

class StorageService {
  static const String _keyGameState = 'game_state';
  static const String _keyCraftingLog = 'crafting_log';
  static const String _keyRevelations = 'revelations';
  static const String _keySettings = 'settings';
  static const String _keyCurrentRecipe = 'current_recipe';
  
  // Singleton pattern
  static final StorageService _instance = StorageService._internal();
  factory StorageService() => _instance;
  StorageService._internal();
  
  SharedPreferences? _prefs;
  
  Future<void> init() async {
    _prefs ??= await SharedPreferences.getInstance();
  }
  
  // Save methods
  Future<bool> saveGameState(GameState state) async {
    await init();
    final json = jsonEncode(state.toJson());
    return await _prefs!.setString(_keyGameState, json);
  }
  
  // Load methods
  Future<GameState?> loadGameState() async {
    await init();
    final json = _prefs!.getString(_keyGameState);
    if (json == null) return null;
    return GameState.fromJson(jsonDecode(json));
  }
  
  // Clear methods
  Future<bool> clearAll() async {
    await init();
    return await _prefs!.clear();
  }
}
```

## Data to Persist

### 1. Game State (Complete)
- Current attempt number
- All crafting log entries
- All revelations (locked/unlocked status)
- Settings (sound, music, text speed)
- Current recipe in progress (if any)

### 2. Individual Settings
Store separately for quick access:
```dart
Future<bool> saveSoundEnabled(bool enabled) async {
  await init();
  return await _prefs!.setBool('sound_enabled', enabled);
}

Future<bool> getSoundEnabled() async {
  await init();
  return _prefs!.getBool('sound_enabled') ?? true;
}
```

### 3. Crafting Log (History)
Save as List of AttemptRecords:
```dart
Future<bool> addAttemptRecord(AttemptRecord record) async {
  await init();
  final currentLog = await loadCraftingLog();
  currentLog.add(record);
  final json = jsonEncode(currentLog.map((r) => r.toJson()).toList());
  return await _prefs!.setString(_keyCraftingLog, json);
}
```

## Persistence Strategy

### When to Save
1. **After each attempt completes** (success or failure)
   - Save AttemptRecord to crafting log
   - Update attempt counter
   - Check and unlock revelations
   - Save complete GameState

2. **When recipe is locked** in Study phase
   - Save current recipe to GameState

3. **When settings change**
   - Save immediately (don't wait for app close)

4. **On app pause/terminate**
   - Save current state in AppLifecycleState listener

### When to Load
1. **On app startup** (main.dart)
   - Load GameState or create initial state
   - Inject into app via constructor or provider-like pattern

2. **When navigating to specific screens**
   - Load relevant data (crafting log for CraftingLogScreen)

## Error Handling

```dart
Future<GameState> loadGameStateOrDefault() async {
  try {
    final state = await loadGameState();
    return state ?? GameState.initial();
  } catch (e) {
    print('Error loading game state: $e');
    return GameState.initial();
  }
}
```

## Reset Progress

```dart
Future<void> resetProgress() async {
  await init();
  await _prefs!.clear();
  // Optionally reload initial state
}
```

## Testing Considerations

- SharedPreferences can be mocked for testing
- Provide methods to check if data exists
- Consider data migration if model structure changes

## Performance

- Cache frequently accessed data in memory
- Don't save on every setState call
- Debounce rapid changes (e.g., dropdown selections)
- Use background isolates for large data serialization (if needed)

## Data Size Considerations

- Each attempt record is ~1-2KB of JSON
- 100 attempts = ~100-200KB (well within SharedPreferences limits)
- No need for database unless scaling to thousands of attempts
- Consider limiting crafting log history (e.g., keep last 50 attempts)

## Backward Compatibility

If adding new fields to models:
```dart
factory GameState.fromJson(Map<String, dynamic> json) {
  return GameState(
    currentAttempt: json['currentAttempt'] as int? ?? 1,
    // Provide defaults for new fields
    newField: json['newField'] as String? ?? 'defaultValue',
  );
}
```
